/**
 * Frontend Merkle Proof Verification Examples
 * 
 * This file demonstrates how to verify merkle proofs off-chain
 * for the Apiary pre-sale whitelist system.
 * 
 * Use Cases:
 * 1. Frontend can check if user is whitelisted before attempting purchase
 * 2. Display "You're whitelisted!" message to eligible users
 * 3. Prevent wasted gas on failed transactions
 * 4. Generate proof for contract call
 */

// ============================================================================
// EXAMPLE 1: React Component with ethers.js
// ============================================================================

import { ethers } from 'ethers';
import { MerkleTree } from 'merkletreejs';
import keccak256 from 'keccak256';

/**
 * Load merkle tree data (generated by generateMerkleTree.js)
 * In production, fetch this from your API/IPFS/CDN
 */
import merkleData from './merkle-tree-output.json';

/**
 * React hook for whitelist verification
 */
function useWhitelistStatus(userAddress) {
    const [isWhitelisted, setIsWhitelisted] = useState(false);
    const [proof, setProof] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        async function checkWhitelist() {
            if (!userAddress) {
                setLoading(false);
                return;
            }

            try {
                // Normalize address to checksum format
                const checksumAddress = ethers.utils.getAddress(userAddress);

                // Check if address is in whitelist
                if (!merkleData.addresses.includes(checksumAddress)) {
                    setIsWhitelisted(false);
                    setProof(null);
                    setLoading(false);
                    return;
                }

                // Get proof for this address
                const userProof = merkleData.proofs[checksumAddress];

                if (userProof) {
                    setIsWhitelisted(true);
                    setProof(userProof);
                } else {
                    setIsWhitelisted(false);
                    setProof(null);
                }

            } catch (error) {
                console.error('Error checking whitelist:', error);
                setIsWhitelisted(false);
                setProof(null);
            } finally {
                setLoading(false);
            }
        }

        checkWhitelist();
    }, [userAddress]);

    return { isWhitelisted, proof, loading };
}

/**
 * React component for pre-sale purchase
 */
function PreSalePurchase({ userAddress, signer }) {
    const { isWhitelisted, proof, loading } = useWhitelistStatus(userAddress);
    const [honeyAmount, setHoneyAmount] = useState('');

    const handlePurchase = async () => {
        if (!isWhitelisted || !proof) {
            alert('You are not whitelisted!');
            return;
        }

        try {
            // Contract instance
            const preSaleContract = new ethers.Contract(
                PRESALE_CONTRACT_ADDRESS,
                PRESALE_ABI,
                signer
            );

            // Convert HONEY amount to wei (18 decimals)
            const honeyAmountWei = ethers.utils.parseUnits(honeyAmount, 18);

            // Call purchaseApiary with proof
            const tx = await preSaleContract.purchaseApiary(
                honeyAmountWei,
                proof // Merkle proof array
            );

            console.log('Transaction sent:', tx.hash);
            await tx.wait();
            console.log('Purchase successful!');

        } catch (error) {
            console.error('Purchase failed:', error);
        }
    };

    if (loading) {
        return <div>Checking whitelist status...</div>;
    }

    if (!isWhitelisted) {
        return (
            <div className="not-whitelisted">
                <p>❌ You are not whitelisted for the pre-sale.</p>
                <p>Contact team to be added to whitelist.</p>
            </div>
        );
    }

    return (
        <div className="presale-purchase">
            <h2>✅ You're Whitelisted!</h2>
            <input
                type="number"
                value={honeyAmount}
                onChange={(e) => setHoneyAmount(e.target.value)}
                placeholder="Amount of HONEY to spend"
            />
            <button onClick={handlePurchase}>
                Purchase APIARY
            </button>
        </div>
    );
}

// ============================================================================
// EXAMPLE 2: Pure JavaScript Verification Function
// ============================================================================

/**
 * Verify merkle proof locally (client-side validation)
 * 
 * @param {string} address - User address to verify
 * @param {string[]} proof - Merkle proof array
 * @param {string} merkleRoot - Merkle root from contract
 * @returns {boolean} - True if proof is valid
 */
function verifyMerkleProof(address, proof, merkleRoot) {
    // Generate leaf hash (must match contract logic)
    const leaf = hashAddress(address);

    // Reconstruct root from proof
    let computedHash = leaf;

    for (const proofElement of proof) {
        if (computedHash < proofElement) {
            // Hash(current, element)
            computedHash = ethers.utils.keccak256(
                ethers.utils.concat([computedHash, proofElement])
            );
        } else {
            // Hash(element, current)
            computedHash = ethers.utils.keccak256(
                ethers.utils.concat([proofElement, computedHash])
            );
        }
    }

    // Compare computed root with expected root
    return computedHash === merkleRoot;
}

/**
 * Hash address to leaf (matches contract logic)
 */
function hashAddress(address) {
    // First hash: keccak256(abi.encode(address))
    const firstHash = ethers.utils.keccak256(
        ethers.utils.defaultAbiCoder.encode(['address'], [address])
    );

    // Second hash: keccak256(bytes.concat(firstHash))
    const leaf = ethers.utils.keccak256(firstHash);

    return leaf;
}

// ============================================================================
// EXAMPLE 3: Vue.js Component
// ============================================================================

const PreSaleComponent = {
    data() {
        return {
            userAddress: null,
            isWhitelisted: false,
            proof: null,
            honeyAmount: '',
            merkleRoot: '0x...' // Get from contract
        };
    },

    async mounted() {
        // Get user address from wallet
        if (window.ethereum) {
            const accounts = await window.ethereum.request({ 
                method: 'eth_requestAccounts' 
            });
            this.userAddress = accounts[0];
            await this.checkWhitelist();
        }
    },

    methods: {
        async checkWhitelist() {
            try {
                const checksumAddress = ethers.utils.getAddress(this.userAddress);

                // Load merkle data
                const response = await fetch('/api/merkle-data');
                const merkleData = await response.json();

                // Check if whitelisted
                if (merkleData.addresses.includes(checksumAddress)) {
                    this.isWhitelisted = true;
                    this.proof = merkleData.proofs[checksumAddress];

                    // Verify proof locally
                    const isValid = verifyMerkleProof(
                        checksumAddress,
                        this.proof,
                        merkleData.merkleRoot
                    );

                    console.log('Proof valid:', isValid);
                }
            } catch (error) {
                console.error('Error checking whitelist:', error);
            }
        },

        async purchase() {
            if (!this.isWhitelisted) {
                alert('Not whitelisted!');
                return;
            }

            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();

            const contract = new ethers.Contract(
                PRESALE_ADDRESS,
                PRESALE_ABI,
                signer
            );

            const amount = ethers.utils.parseUnits(this.honeyAmount, 18);
            const tx = await contract.purchaseApiary(amount, this.proof);
            await tx.wait();

            alert('Purchase successful!');
        }
    },

    template: `
        <div v-if="isWhitelisted">
            <h2>✅ You're whitelisted!</h2>
            <input v-model="honeyAmount" placeholder="HONEY amount" />
            <button @click="purchase">Purchase APIARY</button>
        </div>
        <div v-else>
            <p>❌ Not whitelisted</p>
        </div>
    `
};

// ============================================================================
// EXAMPLE 4: Testing/CLI Script
// ============================================================================

/**
 * Test merkle proof verification from command line
 */
async function testMerkleProof(address) {
    const merkleData = require('./merkle-tree-output.json');

    const checksumAddress = ethers.utils.getAddress(address);

    console.log(`Testing address: ${checksumAddress}`);
    console.log(`Merkle root: ${merkleData.merkleRoot}`);

    if (!merkleData.addresses.includes(checksumAddress)) {
        console.log('❌ Address NOT in whitelist');
        return;
    }

    const proof = merkleData.proofs[checksumAddress];
    console.log(`Proof: ${JSON.stringify(proof, null, 2)}`);

    // Verify locally
    const isValid = verifyMerkleProof(
        checksumAddress,
        proof,
        merkleData.merkleRoot
    );

    console.log(`Verification: ${isValid ? '✅ VALID' : '❌ INVALID'}`);

    // Test on-chain (requires RPC connection)
    const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
    const contract = new ethers.Contract(
        PRESALE_ADDRESS,
        ['function isWhitelisted(address,bytes32[]) view returns (bool)'],
        provider
    );

    const onChainValid = await contract.isWhitelisted(checksumAddress, proof);
    console.log(`On-chain verification: ${onChainValid ? '✅ VALID' : '❌ INVALID'}`);
}

// Run test if called directly
if (require.main === module) {
    const testAddress = process.argv[2];
    if (!testAddress) {
        console.log('Usage: node verifyProof.js <address>');
        process.exit(1);
    }
    testMerkleProof(testAddress);
}

// ============================================================================
// EXAMPLE 5: API Endpoint (Express.js)
// ============================================================================

/**
 * Backend API to provide merkle proof for a given address
 */
const express = require('express');
const app = express();

app.get('/api/whitelist/:address', (req, res) => {
    try {
        const address = ethers.utils.getAddress(req.params.address);
        const merkleData = require('./merkle-tree-output.json');

        if (!merkleData.addresses.includes(address)) {
            return res.json({
                whitelisted: false,
                proof: null
            });
        }

        res.json({
            whitelisted: true,
            proof: merkleData.proofs[address],
            merkleRoot: merkleData.merkleRoot
        });

    } catch (error) {
        res.status(400).json({ error: 'Invalid address' });
    }
});

app.listen(3000, () => {
    console.log('API running on port 3000');
});

// ============================================================================
// EXAMPLE 6: Wagmi/Viem Integration (Modern React)
// ============================================================================

import { useAccount, useContractWrite, usePrepareContractWrite } from 'wagmi';
import { parseUnits } from 'viem';

function ModernPreSale() {
    const { address } = useAccount();
    const { isWhitelisted, proof } = useWhitelistStatus(address);

    const { config } = usePrepareContractWrite({
        address: PRESALE_ADDRESS,
        abi: PRESALE_ABI,
        functionName: 'purchaseApiary',
        args: [
            parseUnits('100', 18), // 100 HONEY
            proof || [] // Merkle proof
        ],
        enabled: isWhitelisted && !!proof
    });

    const { write, isLoading } = useContractWrite(config);

    return (
        <div>
            {isWhitelisted ? (
                <button onClick={write} disabled={isLoading}>
                    {isLoading ? 'Purchasing...' : 'Purchase APIARY'}
                </button>
            ) : (
                <p>Not whitelisted</p>
            )}
        </div>
    );
}

// Export all utilities
export {
    verifyMerkleProof,
    hashAddress,
    useWhitelistStatus,
    PreSalePurchase
};
